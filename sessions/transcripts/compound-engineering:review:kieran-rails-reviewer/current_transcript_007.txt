        "content": "     1→import 'package:flutter/material.dart';\n     2→import 'package:flutter_riverpod/flutter_riverpod.dart';\n     3→import 'package:go_router/go_router.dart';\n     4→import 'package:uuid/uuid.dart';\n     5→\n     6→import '../../../core/supabase_client.dart';\n     7→\n     8→/// Provider for loading a single book with its chapters\n     9→final bookDetailProvider =\n    10→    FutureProvider.family<Map<String, dynamic>?, String>((ref, bookId) async {\n    11→  final supabase = ref.watch(supabaseClientProvider);\n    12→  final response = await supabase\n    13→      .from('books')\n    14→      .select('*, chapters(*)')\n    15→      .eq('id', bookId)\n    16→      .order('order_index', referencedTable: 'chapters')\n    17→      .maybeSingle();\n    18→\n    19→  return response;\n    20→});\n    21→\n    22→class BookEditScreen extends ConsumerStatefulWidget {\n    23→  const BookEditScreen({super.key, this.bookId});\n    24→\n    25→  final String? bookId;\n    26→\n    27→  @override\n    28→  ConsumerState<BookEditScreen> createState() => _BookEditScreenState();\n    29→}\n    30→\n    31→class _BookEditScreenState extends ConsumerState<BookEditScreen> {\n    32→  final _formKey = GlobalKey<FormState>();\n    33→  final _titleController = TextEditingController();\n    34→  final _authorController = TextEditingController();\n    35→  final _descriptionController = TextEditingController();\n    36→  final _coverUrlController = TextEditingController();\n    37→\n    38→  // CEFR levels + descriptive levels\n    39→  static const _validLevels = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2'];\n    40→\n    41→  String _getLevelLabel(String level) {\n    42→    switch (level) {\n    43→      case 'A1':\n    44→        return 'A1 - Beginner';\n    45→      case 'A2':\n    46→        return 'A2 - Elementary';\n    47→      case 'B1':\n    48→        return 'B1 - Intermediate';\n    49→      case 'B2':\n    50→        return 'B2 - Upper Intermediate';\n    51→      case 'C1':\n    52→        return 'C1 - Advanced';\n    53→      case 'C2':\n    54→        return 'C2 - Proficient';\n    55→      default:\n    56→        return level;\n    57→    }\n    58→  }\n    59→\n    60→  String _level = 'B1';\n    61→  bool _isPublished = false;\n    62→  bool _isLoading = false;\n    63→  bool _isSaving = false;\n    64→\n    65→  bool get isNewBook => widget.bookId == null;\n    66→\n    67→  @override\n    68→  void initState() {\n    69→    super.initState();\n    70→    if (!isNewBook) {\n    71→      _loadBook();\n    72→    }\n    73→  }\n    74→\n    75→  Future<void> _loadBook() async {\n    76→    setState(() => _isLoading = true);\n    77→\n    78→    final book = await ref.read(bookDetailProvider(widget.bookId!).future);\n    79→    if (book != null && mounted) {\n    80→      _titleController.text = book['title'] ?? '';\n    81→      _authorController.text = book['author'] ?? '';\n    82→      _descriptionController.text = book['description'] ?? '';\n    83→      _coverUrlController.text = book['cover_image_url'] ?? '';\n    84→      final dbLevel = book['level'] as String? ?? 'B1';\n    85→      setState(() {\n    86→        // Normalize level to valid CEFR levels\n    87→        _level = _validLevels.contains(dbLevel) ? dbLevel : 'B1';\n    88→        _isPublished = book['status'] == 'published';\n    89→        _isLoading = false;\n    90→      });\n    91→    } else {\n    92→      setState(() => _isLoading = false);\n    93→    }\n    94→  }\n    95→\n    96→  @override\n    97→  void dispose() {\n    98→    _titleController.dispose();\n    99→    _authorController.dispose();\n   100→    _descriptionController.dispose();\n   101→    _coverUrlController.dispose();\n   102→    super.dispose();\n   103→  }\n   104→\n   105→  Future<void> _handleSave() async {\n   106→    if (!_formKey.currentState!.validate()) return;\n   107→\n   108→    setState(() => _isSaving = true);\n   109→\n   110→    try {\n   111→      final supabase = ref.read(supabaseClientProvider);\n   112→\n   113→      final data = {\n   114→        'title': _titleController.text.trim(),\n   115→        'author': _authorController.text.trim(),\n   116→        'description': _descriptionController.text.trim(),\n   117→        'cover_image_url': _coverUrlController.text.trim(),\n   118→        'level': _level,\n   119→        'status': _isPublished ? 'published' : 'draft',\n   120→      };\n   121→\n   122→      if (isNewBook) {\n   123→        data['id'] = const Uuid().v4();\n   124→        // Generate slug from title\n   125→        data['slug'] = _titleController.text\n   126→            .trim()\n   127→            .toLowerCase()\n   128→            .replaceAll(RegExp(r'[^a-z0-9\\s-]'), '')\n   129→            .replaceAll(RegExp(r'\\s+'), '-');\n   130→        await supabase.from('books').insert(data);\n   131→\n   132→        if (mounted) {\n   133→          ScaffoldMessenger.of(context).showSnackBar(\n   134→            const SnackBar(content: Text('Book created successfully')),\n   135→          );\n   136→          context.go('/books/${data['id']}');\n   137→        }\n   138→      } else {\n   139→        await supabase.from('books').update(data).eq('id', widget.bookId!);\n   140→\n   141→        if (mounted) {\n   142→          ScaffoldMessenger.of(context).showSnackBar(\n   143→            const SnackBar(content: Text('Book saved successfully')),\n   144→          );\n   145→          ref.invalidate(bookDetailProvider(widget.bookId!));\n   146→        }\n   147→      }\n   148→    } catch (e) {\n   149→      if (mounted) {\n   150→        ScaffoldMessenger.of(context).showSnackBar(\n   151→          SnackBar(\n   152→            content: Text('Error: $e'),\n   153→            backgroundColor: Colors.red,\n   154→          ),\n   155→        );\n   156→      }\n   157→    } finally {\n   158→      if (mounted) {\n   159→        setState(() => _isSaving = false);\n   160→      }\n   161→    }\n   162→  }\n   163→\n   164→  Future<void> _handleDelete() async {\n   165→    final confirmed = await showDialog<bool>(\n   166→      context: context,\n   167→      builder: (context) => AlertDialog(\n   168→        title: const Text('Delete Book'),\n   169→        content: const Text(\n   170→          'Are you sure you want to delete this book? This action cannot be undone.',\n   171→        ),\n   172→        actions: [\n   173→          TextButton(\n   174→            onPressed: () => Navigator.pop(context, false),\n   175→            child: const Text('Cancel'),\n   176→          ),\n   177→          FilledButton(\n   178→            onPressed: () => Navigator.pop(context, true),\n   179→            style: FilledButton.styleFrom(backgroundColor: Colors.red),\n   180→            child: const Text('Delete'),\n   181→          ),\n   182→        ],\n   183→      ),\n   184→    );\n   185→\n   186→    if (confirmed != true) return;\n   187→\n   188→    try {\n   189→      final supabase = ref.read(supabaseClientProvider);\n   190→      await supabase.from('books').delete().eq('id', widget.bookId!);\n   191→\n   192→      if (mounted) {\n   193→        ScaffoldMessenger.of(context).showSnackBar(\n   194→          const SnackBar(content: Text('Book deleted')),\n   195→        );\n   196→        context.go('/books');\n   197→      }\n   198→    } catch (e) {\n   199→      if (mounted) {\n   200→        ScaffoldMessenger.of(context).showSnackBar(\n   201→          SnackBar(content: Text('Error: $e'), backgroundColor: Colors.red),\n   202→        );\n   203→      }\n   204→    }\n   205→  }\n   206→\n   207→  @override\n   208→  Widget build(BuildContext context) {\n   209→    final bookAsync = isNewBook ? null : ref.watch(bookDetailProvider(widget.bookId!));\n   210→\n   211→    return Scaffold(\n   212→      appBar: AppBar(\n   213→        title: Text(isNewBook ? 'New Book' : 'Edit Book'),\n   214→        leading: IconButton(\n   215→          icon: const Icon(Icons.arrow_back),\n   216→          onPressed: () => context.go('/books'),\n   217→        ),\n   218→        actions: [\n   219→          if (!isNewBook)\n   220→            IconButton(\n   221→              icon: const Icon(Icons.delete_outline),\n   222→              color: Colors.red,\n   223→              onPressed: _handleDelete,\n   224→            ),\n   225→          const SizedBox(width: 8),\n   226→          FilledButton(\n   227→            onPressed: _isSaving ? null : _handleSave,\n   228→            child: _isSaving\n   229→                ? const SizedBox(\n   230→                    width: 16,\n   231→                    height: 16,\n   232→                    child: CircularProgressIndicator(\n   233→                      strokeWidth: 2,\n   234→                      color: Colors.white,\n   235→                    ),\n   236→                  )\n   237→                : Text(isNewBook ? 'Create' : 'Save'),\n   238→          ),\n   239→          const SizedBox(width: 16),\n   240→        ],\n   241→      ),\n   242→      body: _isLoading\n   243→          ? const Center(child: CircularProgressIndicator())\n   244→          : Row(\n   245→              crossAxisAlignment: CrossAxisAlignment.start,\n   246→              children: [\n   247→                // Book form\n   248→                Expanded(\n   249→                  flex: 2,\n   250→                  child: SingleChildScrollView(\n   251→                    padding: const EdgeInsets.all(24),\n   252→                    child: Form(\n   253→                      key: _formKey,\n   254→                      child: Column(\n   255→                        crossAxisAlignment: CrossAxisAlignment.start,\n   256→                        children: [\n   257→                          Text(\n   258→                            'Book Details',\n   259→                            style: Theme.of(context).textTheme.titleLarge,\n   260→                          ),\n   261→                          const SizedBox(height: 24),\n   262→\n   263→                          // Title\n   264→                          TextFormField(\n   265→                            controller: _titleController,\n   266→                            decoration: const InputDecoration(\n   267→                              labelText: 'Title',\n   268→                              hintText: 'Enter book title',\n   269→                            ),\n   270→                            validator: (value) {\n   271→                              if (value == null || value.trim().isEmpty) {\n   272→                                return 'Title is required';\n   273→                              }\n   274→                              return null;\n   275→                            },\n   276→                          ),\n   277→                          const SizedBox(height: 16),\n   278→\n   279→                          // Author\n   280→                          TextFormField(\n   281→                            controller: _authorController,\n   282→                            decoration: const InputDecoration(\n   283→                              labelText: 'Author',\n   284→                              hintText: 'Enter author name',\n   285→                            ),\n   286→                          ),\n   287→                          const SizedBox(height: 16),\n   288→\n   289→                          // Description\n   290→                          TextFormField(\n   291→                            controller: _descriptionController,\n   292→                            decoration: const InputDecoration(\n   293→                              labelText: 'Description',\n   294→                              hintText: 'Enter book description',\n   295→                            ),\n   296→                            maxLines: 4,\n   297→                          ),\n   298→                          const SizedBox(height: 16),\n   299→\n   300→                          // Cover URL\n   301→                          TextFormField(\n   302→                            controller: _coverUrlController,\n   303→                            decoration: const InputDecoration(\n   304→                              labelText: 'Cover Image URL',\n   305→                              hintText: 'https://...',\n   306→                            ),\n   307→                          ),\n   308→                          const SizedBox(height: 16),\n   309→\n   310→                          // Level dropdown (CEFR + descriptive levels)\n   311→                          DropdownButtonFormField<String>(\n   312→                            value: _validLevels.contains(_level) ? _level : 'B1',\n   313→                            decoration: const InputDecoration(\n   314→                              labelText: 'Level',\n   315→                            ),\n   316→                            items: _validLevels.map((level) {\n   317→                              return DropdownMenuItem(\n   318→                                value: level,\n   319→                                child: Text(_getLevelLabel(level)),\n   320→                              );\n   321→                            }).toList(),\n   322→                            onChanged: (value) {\n   323→                              if (value != null) {\n   324→                                setState(() => _level = value);\n   325→                              }\n   326→                            },\n   327→                          ),\n   328→                          const SizedBox(height: 16),\n   329→\n   330→                          // Published switch\n   331→                          SwitchListTile(\n   332→                            title: const Text('Published'),\n   333→                            subtitle: const Text(\n   334→                              'When enabled, the book will be visible to users',\n   335→                            ),\n   336→                            value: _isPublished,\n   337→                            onChanged: (value) {\n   338→                              setState(() => _isPublished = value);\n   339→                            },\n   340→                            contentPadding: EdgeInsets.zero,\n   341→                          ),\n   342→                        ],\n   343→                      ),\n   344→                    ),\n   345→                  ),\n   346→                ),\n   347→\n   348→                // Chapters list (only for existing books)\n   349→                if (!isNewBook)\n   350→                  Expanded(\n   351→                    flex: 1,\n   352→                    child: Container(\n   353→                      decoration: BoxDecoration(\n   354→                        border: Border(\n   355→                          left: BorderSide(color: Colors.grey.shade200),\n   356→                        ),\n   357→                      ),\n   358→                      child: bookAsync?.when(\n   359→                            data: (book) {\n   360→                              final chapters = (book?['chapters'] as List? ?? [])\n   361→                                  .cast<Map<String, dynamic>>();\n   362→\n   363→                              return _ChaptersList(\n   364→                                bookId: widget.bookId!,\n   365→                                chapters: chapters,\n   366→                                onRefresh: () => ref.invalidate(\n   367→                                  bookDetailProvider(widget.bookId!),\n   368→                                ),\n   369→                              );\n   370→                            },\n   371→                            loading: () =>\n   372→                                const Center(child: CircularProgressIndicator()),\n   373→                            error: (e, _) => Center(child: Text('Error: $e')),\n   374→                          ) ??\n   375→                          const SizedBox.shrink(),\n   376→                    ),\n   377→                  ),\n   378→              ],\n   379→            ),\n   380→    );\n   381→  }\n   382→}\n   383→\n   384→class _ChaptersList extends ConsumerStatefulWidget {\n   385→  const _ChaptersList({\n   386→    required this.bookId,\n   387→    required this.chapters,\n   388→    required this.onRefresh,\n   389→  });\n   390→\n   391→  final String bookId;\n   392→  final List<Map<String, dynamic>> chapters;\n   393→  final VoidCallback onRefresh;\n   394→\n   395→  @override\n   396→  ConsumerState<_ChaptersList> createState() => _ChaptersListState();\n   397→}\n   398→\n   399→class _ChaptersListState extends ConsumerState<_ChaptersList> {\n   400→  bool _isExtracting = false;\n   401→\n   402→  Future<void> _extractVocabulary() async {\n   403→    if (widget.chapters.isEmpty) {\n   404→      ScaffoldMessenger.of(context).showSnackBar(\n   405→        const SnackBar(content: Text('No chapters to extract vocabulary from')),\n   406→      );\n   407→      return;\n   408→    }\n   409→\n   410→    setState(() => _isExtracting = true);\n   411→\n   412→    // Show loading dialog\n   413→    showDialog(\n   414→      context: context,\n   415→      barrierDismissible: false,\n   416→      builder: (context) => AlertDialog(\n   417→        content: Column(\n   418→          mainAxisSize: MainAxisSize.min,\n   419→          children: [\n   420→            const CircularProgressIndicator(),\n   421→            const SizedBox(height: 16),\n   422→            Text('Extracting vocabulary from ${widget.chapters.length} chapters...'),\n   423→            const SizedBox(height: 8),\n   424→            Text(\n   425→              'This may take a moment...',\n   426→              style: TextStyle(color: Colors.grey.shade600, fontSize: 12),\n   427→            ),\n   428→          ],\n   429→        ),\n   430→      ),\n   431→    );\n   432→\n   433→    try {\n   434→      final supabase = ref.read(supabaseClientProvider);\n   435→\n   436→      // 1. Collect all chapter texts\n   437→      final allTexts = <String>[];\n   438→      for (final chapter in widget.chapters) {\n   439→        // Check for content blocks first\n   440→        final blocksResponse = await supabase\n   441→            .from('content_blocks')\n   442→            .select('text')\n   443→            .eq('chapter_id', chapter['id'])\n   444→            .eq('type', 'text')\n   445→            .order('order_index');\n   446→\n   447→        final blocks = blocksResponse as List;\n   448→        if (blocks.isNotEmpty) {\n   449→          // Use content blocks\n   450→          final blockTexts = blocks.map((b) => b['text'] as String? ?? '').toList();\n   451→          allTexts.add(blockTexts.join('\\n'));\n   452→        } else if (chapter['content'] != null) {\n   453→          // Use legacy content\n   454→          allTexts.add(chapter['content'] as String);\n   455→        }\n   456→      }\n   457→\n   458→      final combinedText = allTexts.join('\\n\\n');\n   459→\n   460→      if (combinedText.trim().isEmpty) {\n   461→        if (mounted) Navigator.pop(context); // Close dialog\n   462→        if (mounted) {\n   463→          ScaffoldMessenger.of(context).showSnackBar(\n   464→            const SnackBar(content: Text('No text content found in chapters')),\n   465→          );\n   466→        }\n   467→        return;\n   468→      }\n   469→\n   470→      // 2. Call edge function\n   471→      final response = await supabase.functions.invoke(\n   472→        'extract-vocabulary',\n   473→        body: {\n   474→          'text': combinedText,\n   475→          'bookId': widget.bookId,\n   476→          'extractAll': true,\n   477→          'saveToDb': true,\n   478→        },\n   479→      );\n   480→\n   481→      if (mounted) Navigator.pop(context); // Close loading dialog\n   482→\n   483→      if (response.status == 200) {\n   484→        final data = response.data as Map<String, dynamic>;\n   485→        final savedCount = data['savedCount'] as int? ?? 0;\n   486→        final words = data['words'] as List? ?? [];\n   487→\n   488→        if (mounted) {\n   489→          ScaffoldMessenger.of(context).showSnackBar(\n   490→            SnackBar(\n   491→              content: Text('✓ ${words.length} words extracted, $savedCount saved to database'),\n   492→              backgroundColor: Colors.green,\n   493→            ),\n   494→          );\n   495→        }\n   496→      } else {\n   497→        final error = response.data?['error'] ?? 'Unknown error';\n   498→        if (mounted) {\n   499→          ScaffoldMessenger.of(context).showSnackBar(\n   500→            SnackBar(content: Text('Error: $error'), backgroundColor: Colors.red),\n   501→          );\n   502→        }\n   503→      }\n   504→    } catch (e) {\n   505→      if (mounted) Navigator.pop(context); // Close loading dialog\n   506→      if (mounted) {\n   507→        ScaffoldMessenger.of(context).showSnackBar(\n   508→          SnackBar(content: Text('Error: $e'), backgroundColor: Colors.red),\n   509→        );\n   510→      }\n   511→    } finally {\n   512→      if (mounted) {\n   513→        setState(() => _isExtracting = false);\n   514→      }\n   515→    }\n   516→  }\n   517→\n   518→  @override\n   519→  Widget build(BuildContext context) {\n   520→    return Column(\n   521→      crossAxisAlignment: CrossAxisAlignment.start,\n   522→      children: [\n   523→        Padding(\n   524→          padding: const EdgeInsets.all(16),\n   525→          child: Column(\n   526→            crossAxisAlignment: CrossAxisAlignment.start,\n   527→            children: [\n   528→              Row(\n   529→                mainAxisAlignment: MainAxisAlignment.spaceBetween,\n   530→                children: [\n   531→                  Text(\n   532→                    'Chapters (${widget.chapters.length})',\n   533→                    style: Theme.of(context).textTheme.titleMedium,\n   534→                  ),\n   535→                  FilledButton.icon(\n   536→                    onPressed: () => context.go('/books/${widget.bookId}/chapters/new'),\n   537→                    icon: const Icon(Icons.add, size: 18),\n   538→                    label: const Text('Add'),\n   539→                  ),\n   540→                ],\n   541→              ),\n   542→              const SizedBox(height: 12),\n   543→              // Vocabulary extraction button\n   544→              SizedBox(\n   545→                width: double.infinity,\n   546→                child: OutlinedButton.icon(\n   547→                  onPressed: _isExtracting ? null : _extractVocabulary,\n   548→                  icon: _isExtracting\n   549→                      ? const SizedBox(\n   550→                          width: 16,\n   551→                          height: 16,\n   552→                          child: 