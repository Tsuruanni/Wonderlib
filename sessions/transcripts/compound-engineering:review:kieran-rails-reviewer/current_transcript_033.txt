          "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:go_router/go_router.dart';\nimport 'package:uuid/uuid.dart';\n\nimport '../../../core/supabase_client.dart';\nimport 'wordlist_list_screen.dart';\n\n/// Provider for loading a single word list with its items\nfinal wordlistDetailProvider =\n    FutureProvider.family<Map<String, dynamic>?, String>((ref, listId) async {\n  final supabase = ref.watch(supabaseClientProvider);\n  final response = await supabase\n      .from('word_lists')\n      .select('*, word_list_items(id, order_index, vocabulary_words(id, word, meaning_tr, level))')\n      .eq('id', listId)\n      .maybeSingle();\n\n  return response;\n});\n\n/// Provider for searching vocabulary words\nfinal vocabularySearchProvider =\n    FutureProvider.family<List<Map<String, dynamic>>, String>((ref, query) async {\n  if (query.isEmpty) return [];\n\n  final supabase = ref.watch(supabaseClientProvider);\n  final response = await supabase\n      .from('vocabulary_words')\n      .select('id, word, meaning_tr, level')\n      .ilike('word', '%$query%')\n      .order('word')\n      .limit(10);\n\n  return List<Map<String, dynamic>>.from(response);\n});\n\nclass WordlistEditScreen extends ConsumerStatefulWidget {\n  const WordlistEditScreen({super.key, this.listId});\n\n  final String? listId;\n\n  @override\n  ConsumerState<WordlistEditScreen> createState() => _WordlistEditScreenState();\n}\n\nclass _WordlistEditScreenState extends ConsumerState<WordlistEditScreen> {\n  final _formKey = GlobalKey<FormState>();\n  final _nameController = TextEditingController();\n  final _descriptionController = TextEditingController();\n  final _searchController = TextEditingController();\n\n  static const _levels = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2'];\n  static const _categories = [\n    ('common_words', 'Common Words'),\n    ('grade_level', 'Grade Level'),\n    ('test_prep', 'Test Prep'),\n    ('thematic', 'Thematic'),\n    ('story_vocab', 'Story Vocabulary'),\n  ];\n\n  String _level = 'B1';\n  String _category = 'common_words';\n  List<Map<String, dynamic>> _wordItems = [];\n  bool _isLoading = false;\n  bool _isSaving = false;\n\n  bool get isNewList => widget.listId == null;\n\n  @override\n  void initState() {\n    super.initState();\n    if (!isNewList) {\n      _loadWordList();\n    }\n  }\n\n  Future<void> _loadWordList() async {\n    setState(() => _isLoading = true);\n\n    final wordlist = await ref.read(wordlistDetailProvider(widget.listId!).future);\n    if (wordlist != null && mounted) {\n      _nameController.text = wordlist['name'] ?? '';\n      _descriptionController.text = wordlist['description'] ?? '';\n\n      // Parse word items\n      final items = wordlist['word_list_items'] as List? ?? [];\n      final wordItems = items\n          .map((item) => {\n                'item_id': item['id'],\n                'order_index': item['order_index'] ?? 0,\n                ...item['vocabulary_words'] as Map<String, dynamic>,\n              })\n          .toList();\n\n      // Sort by order_index\n      wordItems.sort(\n          (a, b) => (a['order_index'] as int).compareTo(b['order_index'] as int));\n\n      setState(() {\n        _level = wordlist['level'] ?? 'B1';\n        _category = wordlist['category'] ?? 'common_words';\n        _wordItems = List<Map<String, dynamic>>.from(wordItems);\n        _isLoading = false;\n      });\n    } else {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  @override\n  void dispose() {\n    _nameController.dispose();\n    _descriptionController.dispose();\n    _searchController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _handleSave() async {\n    if (!_formKey.currentState!.validate()) return;\n\n    setState(() => _isSaving = true);\n\n    try {\n      final supabase = ref.read(supabaseClientProvider);\n\n      final data = {\n        'name': _nameController.text.trim(),\n        'description': _descriptionController.text.trim(),\n        'level': _level,\n        'category': _category,\n        'is_system': true,\n      };\n\n      String listId;\n\n      if (isNewList) {\n        listId = const Uuid().v4();\n        data['id'] = listId;\n        await supabase.from('word_lists').insert(data);\n      } else {\n        listId = widget.listId!;\n        await supabase.from('word_lists').update(data).eq('id', listId);\n      }\n\n      // Update word items\n      // Delete existing items and re-insert\n      await supabase.from('word_list_items').delete().eq('word_list_id', listId);\n\n      if (_wordItems.isNotEmpty) {\n        final items = _wordItems.asMap().entries.map((entry) => {\n              'id': const Uuid().v4(),\n              'word_list_id': listId,\n              'word_id': entry.value['id'],\n              'order_index': entry.key,\n            }).toList();\n\n        await supabase.from('word_list_items').insert(items);\n      }\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(\n            content: Text(isNewList\n                ? 'Word list created successfully'\n                : 'Word list saved successfully'),\n          ),\n        );\n        ref.invalidate(wordlistsProvider);\n        if (isNewList) {\n          context.go('/wordlists/$listId');\n        } else {\n          ref.invalidate(wordlistDetailProvider(widget.listId!));\n        }\n      }\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(\n            content: Text('Error: $e'),\n            backgroundColor: Colors.red,\n          ),\n        );\n      }\n    } finally {\n      if (mounted) {\n        setState(() => _isSaving = false);\n      }\n    }\n  }\n\n  Future<void> _handleDelete() async {\n    final confirmed = await showDialog<bool>(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Delete Word List'),\n        content: const Text(\n          'Are you sure you want to delete this word list? '\n          'This action cannot be undone.',\n        ),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context, false),\n            child: const Text('Cancel'),\n          ),\n          FilledButton(\n            onPressed: () => Navigator.pop(context, true),\n            style: FilledButton.styleFrom(backgroundColor: Colors.red),\n            child: const Text('Delete'),\n          ),\n        ],\n      ),\n    );\n\n    if (confirmed != true) return;\n\n    try {\n      final supabase = ref.read(supabaseClientProvider);\n      await supabase.from('word_lists').delete().eq('id', widget.listId!);\n\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Word list deleted')),\n        );\n        ref.invalidate(wordlistsProvider);\n        context.go('/wordlists');\n      }\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Error: $e'), backgroundColor: Colors.red),\n        );\n      }\n    }\n  }\n\n  void _showAddWordDialog() {\n    _searchController.clear();\n\n    showDialog(\n      context: context,\n      builder: (context) => _AddWordDialog(\n        searchController: _searchController,\n        onWordSelected: (word) {\n          // Check if word already exists\n          if (_wordItems.any((item) => item['id'] == word['id'])) {\n            ScaffoldMessenger.of(context).showSnackBar(\n              const SnackBar(content: Text('Word already in list')),\n            );\n            return;\n          }\n\n          setState(() {\n            _wordItems.add(word);\n          });\n          Navigator.pop(context);\n        },\n      ),\n    );\n  }\n\n  void _removeWord(int index) {\n    setState(() {\n      _wordItems.removeAt(index);\n    });\n  }\n\n  void _moveWord(int oldIndex, int newIndex) {\n    if (newIndex > oldIndex) {\n      newIndex -= 1;\n    }\n    setState(() {\n      final item = _wordItems.removeAt(oldIndex);\n      _wordItems.insert(newIndex, item);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(isNewList ? 'New Word List' : 'Edit Word List'),\n        leading: IconButton(\n          icon: const Icon(Icons.arrow_back),\n          onPressed: () => context.go('/wordlists'),\n        ),\n        actions: [\n          if (!isNewList)\n            IconButton(\n              icon: const Icon(Icons.delete_outline),\n              color: Colors.red,\n              onPressed: _handleDelete,\n            ),\n          const SizedBox(width: 8),\n          FilledButton(\n            onPressed: _isSaving ? null : _handleSave,\n            child: _isSaving\n                ? const SizedBox(\n                    width: 16,\n                    height: 16,\n                    child: CircularProgressIndicator(\n                      strokeWidth: 2,\n                      color: Colors.white,\n                    ),\n                  )\n                : Text(isNewList ? 'Create' : 'Save'),\n          ),\n          const SizedBox(width: 16),\n        ],\n      ),\n      body: _isLoading\n          ? const Center(child: CircularProgressIndicator())\n          : Row(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                // Form\n                Expanded(\n                  flex: 1,\n                  child: SingleChildScrollView(\n                    padding: const EdgeInsets.all(24),\n                    child: Form(\n                      key: _formKey,\n                      child: Column(\n                        crossAxisAlignment: CrossAxisAlignment.start,\n                        children: [\n                          Text(\n                            'List Details',\n                            style: Theme.of(context).textTheme.titleLarge,\n                          ),\n                          const SizedBox(height: 24),\n\n                          // Name\n                          TextFormField(\n                            controller: _nameController,\n                            decoration: const InputDecoration(\n                              labelText: 'Name',\n                              hintText: 'e.g., Common A1 Words',\n                            ),\n                            validator: (value) {\n                              if (value == null || value.trim().isEmpty) {\n                                return 'Name is required';\n                              }\n                              return null;\n                            },\n                          ),\n                          const SizedBox(height: 16),\n\n                          // Description\n                          TextFormField(\n                            controller: _descriptionController,\n                            decoration: const InputDecoration(\n                              labelText: 'Description',\n                              hintText: 'Describe this word list',\n                            ),\n                            maxLines: 3,\n                          ),\n                          const SizedBox(height: 16),\n\n                          // Level\n                          DropdownButtonFormField<String>(\n                            value: _level,\n                            decoration: const InputDecoration(\n                              labelText: 'Level',\n                            ),\n                            items: _levels.map((level) {\n                              return DropdownMenuItem(\n                                value: level,\n                                child: Text(level),\n                              );\n                            }).toList(),\n                            onChanged: (value) {\n                              if (value != null) {\n                                setState(() => _level = value);\n                              }\n                            },\n                          ),\n                          const SizedBox(height: 16),\n\n                          // Category\n                          DropdownButtonFormField<String>(\n                            value: _category,\n                            decoration: const InputDecoration(\n                              labelText: 'Category',\n                            ),\n                            items: _categories.map((cat) {\n                              return DropdownMenuItem(\n                                value: cat.$1,\n                                child: Text(cat.$2),\n                              );\n                            }).toList(),\n                            onChanged: (value) {\n                              if (value != null) {\n                                setState(() => _category = value);\n                              }\n                            },\n                          ),\n                        ],\n                      ),\n                    ),\n                  ),\n                ),\n\n                // Word list\n                Expanded(\n                  flex: 1,\n                  child: Container(\n                    decoration: BoxDecoration(\n                      color: Colors.grey.shade50,\n                      border: Border(\n                        left: BorderSide(color: Colors.grey.shade200),\n                      ),\n                    ),\n                    child: Column(\n                      crossAxisAlignment: CrossAxisAlignment.start,\n                      children: [\n                        // Header\n                        Padding(\n                          padding: const EdgeInsets.all(16),\n                          child: Row(\n                            mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                            children: [\n                              Text(\n                                'Words (${_wordItems.length})',\n                                style: Theme.of(context).textTheme.titleMedium,\n                              ),\n                              TextButton.icon(\n                                onPressed: _showAddWordDialog,\n                                icon: const Icon(Icons.add, size: 18),\n                                label: const Text('Add Word'),\n                              ),\n                            ],\n                          ),\n                        ),\n                        const Divider(height: 1),\n\n                        // Word list\n                        Expanded(\n                          child: _wordItems.isEmpty\n                              ? Center(\n                                  child: Column(\n                                    mainAxisAlignment: MainAxisAlignment.center,\n                                    children: [\n                                      Icon(\n                                        Icons.list,\n                                        size: 48,\n                                        color: Colors.grey.shade400,\n                                      ),\n                                      const SizedBox(height: 16),\n                                      Text(\n                                        'No words yet',\n                                        style: TextStyle(\n                                          color: Colors.grey.shade600,\n                                        ),\n                                      ),\n                                      const SizedBox(height: 8),\n                                      TextButton.icon(\n                                        onPressed: _showAddWordDialog,\n                                        icon: const Icon(Icons.add),\n                                        label: const Text('Add Word'),\n                                      ),\n                                    ],\n                                  ),\n                                )\n                              : ReorderableListView.builder(\n                                  padding: const EdgeInsets.all(8),\n                                  itemCount: _wordItems.length,\n                                  onReorder: _moveWord,\n                                  itemBuilder: (context, index) {\n                                    final word = _wordItems[index];\n                                    return Card(\n                                      key: ValueKey(word['id']),\n                                      margin: const EdgeInsets.symmetric(\n                                        vertical: 4,\n                                      ),\n                                      child: ListTile(\n                                        leading: ReorderableDragStartListener(\n                                          index: index,\n                                          child: const Icon(\n                                            Icons.drag_handle,\n                                            color: Colors.grey,\n                                          ),\n                                        ),\n                                        title: Text(\n                                          word['word'] ?? '',\n                                          style: const TextStyle(\n                                            fontWeight: FontWeight.w500,\n                                          ),\n                                        ),\n                                        subtitle: Text(\n                                          word['meaning_tr'] ?? '',\n                                          maxLines: 1,\n                                          overflow: TextOverflow.ellipsis,\n                                        ),\n                                        trailing: Row(\n                                          mainAxisSize: MainAxisSize.min,\n                                          children: [\n                                            Container(\n                                              padding: const EdgeInsets.symmetric(\n                                                horizontal: 6,\n                                                vertical: 2,\n                                              ),\n                                              decoration: BoxDecoration(\n                                                color: Colors.grey.shade200,\n                                                borderRadius:\n                                                    BorderRadius.circular(4),\n                                              ),\n                                              child: Text(\n                                                '${index + 1}',\n                                                style: const TextStyle(\n                                                  fontSize: 12,\n                                                  fontWeight: FontWeight.bold,\n                                                ),\n                                              ),\n                                            ),\n                                            const SizedBox(width: 8),\n                                            IconButton(\n                                              icon: const Icon(\n                                                Icons.delete_outline,\n                                                size: 20,\n                                              ),\n                                              color: Colors.red,\n                                              onPressed: () => _removeWord(index),\n                                            ),\n                                          ],\n                                        ),\n                                      ),\n                                    );\n                                  },\n                                ),\n                        ),\n                      ],\n                    ),\n                  ),\n                ),\n              ],\n            ),\n    );\n  }\n}\n\nclass _AddWordDialog extends ConsumerStatefulWidget {\n  const _AddWordDialog({\n    required this.searchController,\n    required this.onWordSelected,\n  });\n\n  final TextEditingController searchController;\n  final void Function(Map<String, dynamic> word) onWordSelected;\n\n  @override\n  ConsumerState<_AddWordDialog> createState() => _AddWordDialogState();\n}\n\nclass _AddWordDialogState extends ConsumerState<_AddWordDialog> {\n  String _searchQuery = '';\n\n  @override\n  Widget build(BuildContext context) {\n    final searchResults = ref.watch(vocabularySearchProvider(_searchQuery));\n\n    return AlertDialog(\n      title: const Text('Add Word'),\n      content: SizedBox(\n        width: 400,\n        height: 400,\n        child: Column(\n          children: [\n            TextField(\n              controller: widget.searchController,\n              decoration: const InputDecoration(\n                labelText: 'Search vocabulary',\n                hintText: 'Type to search...',\n                prefixIcon: Icon(Icons.search),\n              ),\n              autofocus: true,\n              onChanged: (value) {\n                setState(() => _searchQuery = value.trim());\n              },\n            ),\n            const SizedBox(height: 16),\n            Expanded(\n              child: searchResults.when(\n                data: (words) {\n                  if (_searchQuery.isEmpty) {\n                    return Center(\n                      child: Text(\n                        'Start typing to search',\n                        style: TextStyle(color: Colors.grey.shade600),\n                      ),\n                    );\n                  }\n\n                  if (words.isEmpty) {\n                    return Center(\n                      child: Text(\n                        'No words found',\n                        style: TextStyle(color: Colors.grey.shade600),\n                      ),\n                    );\n                  }\n\n                  return ListView.builder(\n                    itemCount: words.length,\n                    itemBuilder: (context, index) {\n                      final word = words[index];\n                      return ListTile(\n                        title: Text(word['word'] ?? ''),\n                        subtitle: Text(word['meaning_tr'] ?? ''),\n                        trailing: Text(\n                          word['level'] ?? '',\n                          style: TextStyle(\n                            color: Colors.grey.shade600,\n                            fontSize: 12,\n                          ),\n                        ),\n                        onTap: () => widget.onWordSelected(word),\n                      );\n                    },\n                  );\n                },\n                loading: () => const Center(child: CircularProgressIndicator()),\n                error: (error, _) => Center(\n                  child: Text('Error: $error'),\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n      actions: [\n        TextButton(\n          onPressed: () => Navigator.pop(context),\n          child: const Text('Cancel'),\n        ),\n      ],\n    );\n  }\n}\n"
        },
        "caller": {
          "type": "direct"
        }
      }
    ]
  },
  {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01JkWz3vbaTRKBy4A9Q97HY9",
        "type": "tool_result",
        "content": "File created successfully at: /Users/wonderelt/Desktop/readeng_admin/lib/features/wordlists/screens/wordlist_edit_screen.dart"
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "text",
