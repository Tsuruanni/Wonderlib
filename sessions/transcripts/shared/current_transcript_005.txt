        "content": "     1→import 'package:flutter_riverpod/flutter_riverpod.dart';\n     2→\n     3→import '../../domain/entities/book.dart';\n     4→import '../../domain/entities/chapter.dart';\n     5→import '../../domain/entities/reading_progress.dart';\n     6→import '../../domain/repositories/student_assignment_repository.dart';\n     7→import 'auth_provider.dart';\n     8→import 'repository_providers.dart';\n     9→import 'student_assignment_provider.dart';\n    10→\n    11→/// Provides all published books with optional filters\n    12→final booksProvider = FutureProvider.family<List<Book>, BookFilters?>((ref, filters) async {\n    13→  final bookRepo = ref.watch(bookRepositoryProvider);\n    14→  final result = await bookRepo.getBooks(\n    15→    level: filters?.level,\n    16→    genre: filters?.genre,\n    17→    ageGroup: filters?.ageGroup,\n    18→    page: filters?.page ?? 1,\n    19→    pageSize: filters?.pageSize ?? 20,\n    20→  );\n    21→  return result.fold(\n    22→    (failure) => [],\n    23→    (books) => books,\n    24→  );\n    25→});\n    26→\n    27→/// Provides a single book by ID\n    28→final bookByIdProvider = FutureProvider.family<Book?, String>((ref, id) async {\n    29→  final bookRepo = ref.watch(bookRepositoryProvider);\n    30→  final result = await bookRepo.getBookById(id);\n    31→  return result.fold(\n    32→    (failure) => null,\n    33→    (book) => book,\n    34→  );\n    35→});\n    36→\n    37→/// Provides book search results\n    38→final bookSearchProvider = FutureProvider.family<List<Book>, String>((ref, query) async {\n    39→  if (query.isEmpty) return [];\n    40→  final bookRepo = ref.watch(bookRepositoryProvider);\n    41→  final result = await bookRepo.searchBooks(query);\n    42→  return result.fold(\n    43→    (failure) => [],\n    44→    (books) => books,\n    45→  );\n    46→});\n    47→\n    48→/// Provides recommended books for current user\n    49→final recommendedBooksProvider = FutureProvider<List<Book>>((ref) async {\n    50→  final userId = ref.watch(currentUserIdProvider);\n    51→  if (userId == null) return [];\n    52→\n    53→  final bookRepo = ref.watch(bookRepositoryProvider);\n    54→  final result = await bookRepo.getRecommendedBooks(userId);\n    55→  return result.fold(\n    56→    (failure) => [],\n    57→    (books) => books,\n    58→  );\n    59→});\n    60→\n    61→/// Provides books user is currently reading\n    62→final continueReadingProvider = FutureProvider<List<Book>>((ref) async {\n    63→  final userId = ref.watch(currentUserIdProvider);\n    64→  if (userId == null) return [];\n    65→\n    66→  final bookRepo = ref.watch(bookRepositoryProvider);\n    67→  final result = await bookRepo.getContinueReading(userId);\n    68→  return result.fold(\n    69→    (failure) => [],\n    70→    (books) => books,\n    71→  );\n    72→});\n    73→\n    74→/// Provides chapters for a book\n    75→final chaptersProvider = FutureProvider.family<List<Chapter>, String>((ref, bookId) async {\n    76→  final bookRepo = ref.watch(bookRepositoryProvider);\n    77→  final result = await bookRepo.getChapters(bookId);\n    78→  return result.fold(\n    79→    (failure) => [],\n    80→    (chapters) => chapters,\n    81→  );\n    82→});\n    83→\n    84→/// Provides a single chapter by ID\n    85→final chapterByIdProvider = FutureProvider.family<Chapter?, String>((ref, chapterId) async {\n    86→  final bookRepo = ref.watch(bookRepositoryProvider);\n    87→  final result = await bookRepo.getChapterById(chapterId);\n    88→  return result.fold(\n    89→    (failure) => null,\n    90→    (chapter) => chapter,\n    91→  );\n    92→});\n    93→\n    94→/// Provides reading progress for a book\n    95→final readingProgressProvider = FutureProvider.family<ReadingProgress?, String>((ref, bookId) async {\n    96→  final userId = ref.watch(currentUserIdProvider);\n    97→  if (userId == null) return null;\n    98→\n    99→  final bookRepo = ref.watch(bookRepositoryProvider);\n   100→  final result = await bookRepo.getReadingProgress(\n   101→    userId: userId,\n   102→    bookId: bookId,\n   103→  );\n   104→  return result.fold(\n   105→    (failure) => null,\n   106→    (progress) => progress,\n   107→  );\n   108→});\n   109→\n   110→/// Notifier for marking chapters as complete\n   111→class ChapterCompletionNotifier extends StateNotifier<AsyncValue<void>> {\n   112→  final Ref _ref;\n   113→\n   114→  ChapterCompletionNotifier(this._ref) : super(const AsyncValue.data(null));\n   115→\n   116→  Future<void> markComplete({\n   117→    required String bookId,\n   118→    required String chapterId,\n   119→  }) async {\n   120→    final userId = _ref.read(currentUserIdProvider);\n   121→    if (userId == null) return;\n   122→\n   123→    state = const AsyncValue.loading();\n   124→\n   125→    final bookRepo = _ref.read(bookRepositoryProvider);\n   126→    final result = await bookRepo.markChapterComplete(\n   127→      userId: userId,\n   128→      bookId: bookId,\n   129→      chapterId: chapterId,\n   130→    );\n   131→\n   132→    result.fold(\n   133→      (failure) => state = AsyncValue.error(failure, StackTrace.current),\n   134→      (progress) async {\n   135→        state = const AsyncValue.data(null);\n   136→        // Invalidate providers to refresh UI\n   137→        _ref.invalidate(readingProgressProvider(bookId));\n   138→        _ref.invalidate(continueReadingProvider); // Refresh continue reading list\n   139→\n   140→        // Update assignment progress if this book is part of an assignment\n   141→        await _updateAssignmentProgress(\n   142→          userId: userId,\n   143→          bookId: bookId,\n   144→          chapterId: chapterId,\n   145→          completedChapterIds: progress.completedChapterIds,\n   146→        );\n   147→      },\n   148→    );\n   149→  }\n   150→\n   151→  /// Check if book is part of an active assignment and update progress\n   152→  Future<void> _updateAssignmentProgress({\n   153→    required String userId,\n   154→    required String bookId,\n   155→    required String chapterId,\n   156→    required List<String> completedChapterIds,\n   157→  }) async {\n   158→    try {\n   159→      // Get active assignments\n   160→      final assignmentRepo = _ref.read(studentAssignmentRepositoryProvider);\n   161→      final assignmentsResult = await assignmentRepo.getActiveAssignments(userId);\n   162→\n   163→      assignmentsResult.fold(\n   164→        (failure) {}, // Silently fail - don't break chapter completion\n   165→        (assignments) async {\n   166→          // Find assignments that include this book\n   167→          for (final assignment in assignments) {\n   168→            if (assignment.bookId == bookId &&\n   169→                assignment.status != StudentAssignmentStatus.completed) {\n   170→              // Get all chapters for the book (book-based assignments)\n   171→              final bookRepo = _ref.read(bookRepositoryProvider);\n   172→              final chaptersResult = await bookRepo.getChapters(bookId);\n   173→\n   174→              final totalChapters = chaptersResult.fold(\n   175→                (failure) => 0,\n   176→                (chapters) => chapters.length,\n   177→              );\n   178→\n   179→              if (totalChapters == 0) {\n   180→                continue;\n   181→              }\n   182→\n   183→              // Calculate progress: completed chapters / total chapters in book\n   184→              final progress = (completedChapterIds.length / totalChapters) * 100;\n   185→\n   186→              // Update assignment progress\n   187→              if (progress >= 100) {\n   188→                // All chapters complete - mark assignment as complete\n   189→                await assignmentRepo.completeAssignment(\n   190→                  userId,\n   191→                  assignment.assignmentId,\n   192→                  null, // No score for reading completion\n   193→                );\n   194→              } else {\n   195→                // Update progress\n   196→                await assignmentRepo.updateAssignmentProgress(\n   197→                  userId,\n   198→                  assignment.assignmentId,\n   199→                  progress,\n   200→                );\n   201→              }\n   202→\n   203→              // Invalidate assignment providers to refresh UI\n   204→              _ref.invalidate(studentAssignmentsProvider);\n   205→              _ref.invalidate(activeAssignmentsProvider);\n   206→              _ref.invalidate(studentAssignmentDetailProvider(assignment.assignmentId));\n   207→            }\n   208→          }\n   209→        },\n   210→      );\n   211→    } catch (e) {\n   212→      // Don't throw - assignment update failure shouldn't break chapter completion\n   213→    }\n   214→  }\n   215→}\n   216→\n   217→/// Provider for chapter completion notifier\n   218→final chapterCompletionProvider =\n   219→    StateNotifierProvider<ChapterCompletionNotifier, AsyncValue<void>>((ref) {\n   220→  return ChapterCompletionNotifier(ref);\n   221→});\n   222→\n   223→/// Book filters\n   224→class BookFilters {\n   225→  final String? level;\n   226→  final String? genre;\n   227→  final String? ageGroup;\n   228→  final int page;\n   229→  final int pageSize;\n   230→\n   231→  const BookFilters({\n   232→    this.level,\n   233→    this.genre,\n   234→    this.ageGroup,\n   235→    this.page = 1,\n   236→    this.pageSize = 20,\n   237→  });\n   238→\n   239→  BookFilters copyWith({\n   240→    String? level,\n   241→    String? genre,\n   242→    String? ageGroup,\n   243→    int? page,\n   244→    int? pageSize,\n   245→  }) {\n   246→    return BookFilters(\n   247→      level: level ?? this.level,\n   248→      genre: genre ?? this.genre,\n   249→      ageGroup: ageGroup ?? this.ageGroup,\n   250→      page: page ?? this.page,\n   251→      pageSize: pageSize ?? this.pageSize,\n   252→    );\n   253→  }\n   254→}\n   255→\n   256→/// Reading controller for updating progress\n   257→class ReadingController extends StateNotifier<AsyncValue<ReadingProgress?>> {\n   258→  final Ref _ref;\n   259→  final String bookId;\n   260→\n   261→  ReadingController(this._ref, this.bookId) : super(const AsyncValue.loading()) {\n   262→    _loadProgress();\n   263→  }\n   264→\n   265→  Future<void> _loadProgress() async {\n   266→    final userId = _ref.read(currentUserIdProvider);\n   267→    if (userId == null) {\n   268→      state = const AsyncValue.data(null);\n   269→      return;\n   270→    }\n   271→\n   272→    final bookRepo = _ref.read(bookRepositoryProvider);\n   273→    final result = await bookRepo.getReadingProgress(\n   274→      userId: userId,\n   275→      bookId: bookId,\n   276→    );\n   277→\n   278→    state = result.fold(\n   279→      (failure) => AsyncValue.error(failure.message, StackTrace.current),\n   280→      (progress) => AsyncValue.data(progress),\n   281→    );\n   282→  }\n   283→\n   284→  Future<void> updateProgress({\n   285→    String? chapterId,\n   286→    int? currentPage,\n   287→    double? completionPercentage,\n   288→    int? additionalReadingTime,\n   289→    bool? isCompleted,\n   290→  }) async {\n   291→    final current = state.valueOrNull;\n   292→    if (current == null) return;\n   293→\n   294→    final updated = current.copyWith(\n   295→      chapterId: chapterId ?? current.chapterId,\n   296→      currentPage: currentPage ?? current.currentPage,\n   297→      completionPercentage: completionPercentage ?? current.completionPercentage,\n   298→      totalReadingTime: current.totalReadingTime + (additionalReadingTime ?? 0),\n   299→      isCompleted: isCompleted ?? current.isCompleted,\n   300→      completedAt: (isCompleted ?? false) ? DateTime.now() : current.completedAt,\n   301→      updatedAt: DateTime.now(),\n   302→    );\n   303→\n   304→    final bookRepo = _ref.read(bookRepositoryProvider);\n   305→    final result = await bookRepo.updateReadingProgress(updated);\n   306→\n   307→    state = result.fold(\n   308→      (failure) => AsyncValue.error(failure.message, StackTrace.current),\n   309→      (progress) => AsyncValue.data(progress),\n   310→    );\n   311→  }\n   312→}\n   313→\n   314→final readingControllerProvider = StateNotifierProvider.family<\n   315→    ReadingController, AsyncValue<ReadingProgress?>, String>((ref, bookId) {\n   316→  return ReadingController(ref, bookId);\n   317→});\n   318→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01SfNHnTqjUAyPTdjfqTDq99",
        "type": "tool_result",
